Q1: thread_switch needs to save/restore only the callee-save registers. Why?

A1: Because thread_switch is called only in function thread_schedule, which is called and returns as if it were a conventional procedure in file 'uthread.c'. So each function which calls thread_schedule must have saved all needed registers other than the callee-save ones, which is carried out by codes automatically generated by the C compiler, even though the C code doesn't explicitly impose it.

Q2: This sets a breakpoint at line 60 of uthread.c. The breakpoint may (or may not) be triggered before you even run uthread. How could that happen?

A2: After setting the breakpoint, I checked it at once and got:

(gdb) info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   <MULTIPLE>
1.1                         y   0x000000000000003e in thread_sched
ule at user/uthread.c:60
1.2                         y   0x000000000000005e in thread_sched
ule at user/uthread.c:60

This indicates that GDB sets breakpoints to addresses both 0x3e and 0x5e. Type c to GDB, I got a breakpoint hit before xv6 finishing its booting. Disassembling the current procedure, I got:

=> 0x000000000000003e <+24>:    mv      a0,s2
   0x0000000000000040 <+26>:    auipc   ra,0x0
   0x0000000000000044 <+30>:    jalr    1702(ra) # 0x6e6 <memcmp+52>

Check the file 'uthread.asm' to get a totally different result:

  3e:   4791                    li      a5,4 
  40:   00009817                auipc   a6,0x9
  44:   f3080813                addi    a6,a6,-208 # 8f70 <base>

Then things are clear that the breakpoint was hit while the kernel executing its startup codes just at the breakpoint address. Things originate from the shared virtual address space between the kernel and user programs and among all user programs. However, it depends on the fact that the kernel came to hit the point before uthread, which may not be true for another version of kernel. So the breakpoint may or may not be triggered before running uthread.

Q3: Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing.

A3: Everything is done sequentially with 1 thread, however, concurrently with 2. There's a dangerous gap between a thread finds a slot to insert a key-value pair and it finishes the inserting work. Specifically, here it is:


static 
void put(int key, int value)
{
  int i = key % NBUCKET;

  // is the key already present?
  struct entry *e = 0;
  for (e = table[i]; e != 0; e = e->next) {
    if (e->key == key)
      break;
  }
  if(e){
    // update the existing key.
    e->value = value;
  } else {
    // the new is new.
    insert(key, value, &table[i], table[i]);
  }

}

Suppose that a calling thread of put just ended its for-loop finding nothing corresponding to key so that now e equals 0. However, just before it makes a call to insert or just before insert completes updating works for table[i], another thread happens to do another job on table[i] in put and just got e == 0 which terminated the for-loop. Then the two threads will both try to update &table[i] to their own newly allocated and filled entries, one of which will definitely gets lost from the race. A suitable sequence which triggers this situation could be:

thread 0:
    condition e == 0 just terminated the for clause in the call to put(100, 0)
thread 1:
    condition e == 0 just terminated the for clause in the call to put(105, 0)

at the same time, with schematic keys 100 and 105 (maybe another ones in real life) generated from the random engine and NBUCKET == 5 in the source code.
