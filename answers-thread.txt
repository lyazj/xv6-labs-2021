Q1: thread_switch needs to save/restore only the callee-save registers. Why?

A1: Because thread_switch is called only in function thread_schedule, which is called and returns as if it were a conventional procedure in file 'uthread.c'. So each function which calls thread_schedule must have saved all needed registers other than the callee-save ones, which is carried out by codes automatically generated by the C compiler, even though the C code doesn't explicitly impose it.

Q2: This sets a breakpoint at line 60 of uthread.c. The breakpoint may (or may not) be triggered before you even run uthread. How could that happen?

A2: After setting the breakpoint, I checked it at once and got:

(gdb) info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   <MULTIPLE>
1.1                         y   0x000000000000003e in thread_sched
ule at user/uthread.c:60
1.2                         y   0x000000000000005e in thread_sched
ule at user/uthread.c:60

This indicates that GDB sets breakpoints to addresses both 0x3e and 0x5e. Type c to GDB, I got a breakpoint hit before xv6 finishing its booting. Disassembling the current procedure, I got:

=> 0x000000000000003e <+24>:    mv      a0,s2
   0x0000000000000040 <+26>:    auipc   ra,0x0
   0x0000000000000044 <+30>:    jalr    1702(ra) # 0x6e6 <memcmp+52>

Check the file 'uthread.asm' to get a totally different result:

  3e:   4791                    li      a5,4 
  40:   00009817                auipc   a6,0x9
  44:   f3080813                addi    a6,a6,-208 # 8f70 <base>

Then things are clear that the breakpoint was hit while the kernel executing its startup codes just at the breakpoint address. Things originate from the shared virtual address space between the kernel and user programs and among all user programs. However, it depends on the fact that the kernel came to hit the point before uthread, which may not be true for another version of kernel. So the breakpoint may or may not be triggered before running uthread.
